/**
 * @file æ—¥å¿—å·¥å…·
 * @author JunBin.Yang
 */

import { hilog } from "@kit.PerformanceAnalysisKit";
import { Any } from "@core/common"

/**
 * å®šä¹‰æ—¥å¿—çº§åˆ«æšä¸¾
 */
export enum LogLevel {
  DEBUG = hilog.LogLevel.DEBUG,
  INFO = hilog.LogLevel.INFO,
  WARN = hilog.LogLevel.WARN,
  ERROR = hilog.LogLevel.ERROR,
  FATAL = hilog.LogLevel.FATAL
}

/**
 * å®šä¹‰æ—¥å¿—é€‰é¡¹æ¥å£
 */
export interface LogOption {
  domain: number;
  tag: string;
  icon: string;
  close: boolean;
}

/**
 * æŠ½è±¡æ—¥å¿—å†™å…¥å™¨æ¥å£ï¼Œç”¨äºæ‰©å±•ä¸åŒçš„å†™å…¥æ¸ é“
 */
export abstract class LogWriter {
  abstract write(level: LogLevel, domain: number, tag: string, ...message: Any[]): void;
}

/**
 * é»˜è®¤æ—¥å¿—å†™å…¥å™¨
 */
export class DefaultLogWriter extends LogWriter {
  constructor() {
    super();
  }

  write(level: LogLevel, domain: number, tag: string, message: string): void {
    switch (level) {
      case LogLevel.DEBUG:
        hilog.debug(domain, tag, message);
        break;
      case LogLevel.INFO:
        hilog.info(domain, tag, message);
        break;
      case LogLevel.WARN:
        hilog.warn(domain, tag, message);
        break;
      case LogLevel.ERROR:
        hilog.error(domain, tag, message);
        break;
      case LogLevel.FATAL:
        hilog.fatal(domain, tag, message);
        break;
    }
  }
}

/**
 * æ—¥å¿—å·¥å…·æ ¸å¿ƒç±»
 */
export class Logger {
  /**
   * é»˜è®¤é…ç½®
   */
  private static option: LogOption = {
    domain: 0xFF00,
    tag: 'Arkly',
    icon: 'ğŸ—’ï¸',
    close: false
  };
  /**
   * å½“å‰ä½¿ç”¨çš„æ—¥å¿—å†™å…¥å™¨
   */
  private static writer: LogWriter = new DefaultLogWriter();
  /**
   * åˆå§‹åŒ–é…ç½®
   * @param option é…ç½®é¡¹
   * @param writer è‡ªå®šä¹‰å†™å…¥å™¨å®ä¾‹
   */
  static init(option: Partial<LogOption>, writer?: LogWriter) {
    if (option.domain !== undefined) Logger.option.domain = option.domain;
    if (option.tag !== undefined) Logger.option.tag = option.tag;
    if (option.icon !== undefined) Logger.option.icon = option.icon;
    if (option.close !== undefined) Logger.option.close = option.close;
    Logger.writer = writer ?? new DefaultLogWriter();
  }
  /**
   * è®¾ç½®è‡ªå®šä¹‰æ—¥å¿—å†™å…¥å™¨ï¼ˆç”¨äºæ‰©å±•æ–‡ä»¶ã€è¿œç«¯æœåŠ¡ç­‰æ¸ é“ï¼‰
   * @param writer è‡ªå®šä¹‰å†™å…¥å™¨å®ä¾‹
   */
  static setWriter(writer: LogWriter) {
    Logger.writer = writer;
  }
  /**
   * æ‰‹åŠ¨å…³é—­æ‰€æœ‰æ—¥å¿—è¾“å‡º
   */
  static disable() {
    Logger.option.close = true;
  }
  /**
   * æ‰‹åŠ¨å¼€å¯æ‰€æœ‰æ—¥å¿—è¾“å‡º
   */
  static enable() {
    Logger.option.close = false;
  }
  /**
   * è°ƒè¯•çº§åˆ«æ—¥å¿—
   * @param data æ—¥å¿—å†…å®¹
   * @param tag è‡ªå®šä¹‰æ ‡ç­¾
   */
  static debug(data: Any, tag?: string) {
    Logger.log(LogLevel.DEBUG, data, tag);
  }
  /**
   * ä¿¡æ¯çº§åˆ«æ—¥å¿—
   * @param data æ—¥å¿—å†…å®¹
   * @param tag è‡ªå®šä¹‰æ ‡ç­¾
   */
  static info(data: Any, tag?: string) {
    Logger.log(LogLevel.INFO, data, tag);
  }
  /**
   * è­¦å‘Šçº§åˆ«æ—¥å¿—
   * @param data æ—¥å¿—å†…å®¹
   * @param tag è‡ªå®šä¹‰æ ‡ç­¾
   */
  static warn(data: Any, tag?: string) {
    Logger.log(LogLevel.WARN, data, tag);
  }
  /**
   * é”™è¯¯çº§åˆ«æ—¥å¿—
   * @param data æ—¥å¿—å†…å®¹
   * @param tag è‡ªå®šä¹‰æ ‡ç­¾
   */
  static error(data: Any, tag?: string) {
    Logger.log(LogLevel.ERROR, data, tag);
  }
  /**
   * è‡´å‘½é”™è¯¯çº§åˆ«æ—¥å¿—
   * @param data æ—¥å¿—å†…å®¹
   * @param tag è‡ªå®šä¹‰æ ‡ç­¾
   */
  static fatal(data: Any, tag?: string) {
    Logger.log(LogLevel.FATAL, data, tag);
  }
  /**
   * æ ¸å¿ƒæ—¥å¿—å¤„ç†æ–¹æ³•
   * @param level æ—¥å¿—çº§åˆ«
   * @param data æ—¥å¿—å†…å®¹
   * @param tag è‡ªå®šä¹‰æ ‡ç­¾
   */
  private static log(level: LogLevel, data: Any, tag?: string) {
    if (Logger.option.close) return;
    const domain = Logger.option.domain!;
    const finalTag = tag || Logger.option.tag!;
    const message = Logger.format(data);
    /**
     * é€šè¿‡å†™å…¥å™¨å†™å…¥æ—¥å¿—ï¼ˆè§£è€¦å…·ä½“çš„è¾“å‡ºæ–¹å¼ï¼‰
     */
    Logger.writer.write(level, domain, finalTag, message);
  }
  /**
   * æ ¼å¼åŒ–æ—¥å¿—æ•°æ®
   * @param data åŸå§‹æ•°æ®
   * @returns æ ¼å¼åŒ–åçš„å­—ç¬¦ä¸²
   */
  private static format(data: Any): string {
    if (data === null || data === undefined) return 'null';

    switch (typeof data) {
      case "object":
        return Logger.objToJson(data);
      case "string":
        if (data.startsWith("{") && data.endsWith("}")) {
          try {
            return Logger.objToJson(JSON.parse(data));
          } catch (e) {
            return data;
          }
        } else {
          return data;
        }
      default:
        return String(data);
    }
  }
  /**
   * å¯¹è±¡è½¬æ ¼å¼åŒ–çš„JSONå­—ç¬¦ä¸²
   * @param data ç›®æ ‡å¯¹è±¡
   * @returns å¸¦å›¾æ ‡ç¼©è¿›çš„JSONå­—ç¬¦ä¸²
   */
  private static objToJson(data: object): string {
    const icon = Logger.option.icon || '|';
    return `${icon} ${JSON.stringify(data, null, 2).replace(/\n/g, `\n${icon} `)}`;
  }
}